# JavaScript Execution Context & Call Stack

## ğŸ§  Theory: Execution Context (EC)

An **Execution Context** is the environment where JavaScript code runs. Every time a function runs, a new execution context is created.

### Types of Execution Contexts

1. **Global Execution Context (GEC)** â€“ created when your JS file starts running
2. **Functional Execution Context (FEC)** â€“ created every time a function is invoked
3. **Eval Execution Context** â€“ created when `eval()` is used (rarely relevant in modern dev)

### What Technically Is an Execution Context?

Think of Execution Context as a "box" of data structures created whenever JavaScript starts running code â€” either globally or in a function.

ğŸ“¦ **Internally, an EC consists of:**

1. **Memory/Variable Environment (Creation Phase)**:
   - All variables, functions, and arguments are stored here
   - Functions are stored fully; variables are stored with `undefined` (if `var`)

2. **Code Execution Phase**: 
   - Executes line-by-line
   - Assigns actual values to variables, runs functions

3. **this Binding**:
   - In global context: `this` â†’ `window` (or `global` in Node)
   - In function: depends on how the function is called

### Each EC has:
- **Variable Environment (VE)**: memory allocated to variables/functions
- **Scope Chain**: the context it has access to
- **this binding**: value of `this` keyword

## ğŸ§ª Call Stack

JavaScript is single-threaded. It uses a call stack to manage function calls.

```javascript
function a() {
    console.log("a");
    b();
}

function b() {
    console.log("b");
    c();
}

function c() {
    console.log("c");
}

a();
```

### ğŸ” What happens here?

1. GEC created â†’ code starts
2. `a()` is called â†’ a()'s FEC pushed to call stack
3. Inside a, `b()` is called â†’ FEC for b pushed
4. Inside b, `c()` is called â†’ FEC for c pushed
5. c finishes â†’ its EC is popped
6. Then b, then a, then GEC

## ğŸ“Œ Example Breakdown

```javascript
function greet(name) {
    var message = "Hello " + name;
    return message;
}

var user = "Vijay";
var output = greet(user);
console.log(output);
```

### ğŸ§  Step-by-step:

**1. Global EC is created:**
- **Memory Phase:**
  - `greet` â†’ [function]
  - `user` â†’ undefined
  - `output` â†’ undefined
  - `console` â†’ [object]

**2. Code Execution Phase:**
- `user` â†’ "Vijay"
- `output` â†’ calls `greet("Vijay")`

**3. New EC for greet() is created:**
- **Memory:**
  - `name` â†’ "Vijay"
  - `message` â†’ undefined
- **Execution:**
  - `message` â†’ "Hello Vijay"
  - Returns "Hello Vijay" â†’ assigned to output

**4. GEC logs "Hello Vijay"**

## âœ… Practice Examples

### Example 1:
```javascript
console.log("start");

function foo() {
    console.log("inside foo");
}

foo();
console.log("end");
```

**Output Order:** `start` â†’ `inside foo` â†’ `end`

### Example 2:
```javascript
function outer() {
    function inner() {
        console.log("inner");
    }
    console.log("outer");
    inner();
}

outer();
```

**Output Order:** `outer` â†’ `inner`

## ğŸ¯ Key Takeaways

- Execution Context is a "box" of data structures that manages code execution
- JavaScript uses a call stack to manage function calls in LIFO (Last In, First Out) order
- Each context has two phases: Memory (Creation) and Code Execution
- Understanding EC is crucial for grasping hoisting, scope, and closures

---
